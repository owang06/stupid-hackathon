<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>ScreamStream - Voice-Controlled YouTube Volume</title>

    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- YouTube IFrame API (functionality) -->
    <script src="https://www.youtube.com/iframe_api"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

        * { font-family: 'Inter', sans-serif; }

        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom right, #0b1020, #111827);
        }

        #pitchVisualizer { border-radius: 12px; }

        #facecam {
            width: 100%;
            height: auto;
            object-fit: cover;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(76, 175, 80, 0.25);
            transform: scaleX(-1);
        }

        /* Custom slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-track {
            background: linear-gradient(to right, #10b981, #f59e0b, #ef4444);
            height: 8px;
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: white;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 2px solid #10b981;
        }

        input[type="range"]::-moz-range-track {
            background: linear-gradient(to right, #10b981, #f59e0b, #ef4444);
            height: 8px;
            border-radius: 4px;
        }

        input[type="range"]::-moz-range-thumb {
            background: white;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: 2px solid #10b981;
            cursor: pointer;
        }

        .gradient-text {
            background: linear-gradient(135deg, #10b981 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body class="min-h-screen text-white">
    <div class="container mx-auto px-4 py-6 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-4">
            <h1 class="text-4xl font-bold gradient-text mb-1">ScreamStream</h1>
            <p class="text-gray-400 text-sm">Control YouTube volume with your voice ‚Äî head-tilt for skip</p>
        </div>

        <!-- Main Grid: left player, right controls -->
        <div class="grid gap-4 grid-cols-1 md:grid-cols-[1fr_320px] items-start">
            <!-- LEFT: YouTube player + URL loader -->
            <div class="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-4 shadow-2xl border border-gray-700/50">
                <div class="relative rounded-xl overflow-hidden shadow-2xl" style="width:100%; aspect-ratio: 16/9;">
                    <iframe id="youtubeFrame"
                            class="w-full h-full block border-0"
                            src="https://www.youtube.com/embed/Oo9EbArcQ1c?enablejsapi=1&controls=1&rel=0&modestbranding=1"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                            allowfullscreen>
                    </iframe>
                </div>

                <div class="mt-3 flex gap-2">
                    <input id="youtubeURLInput"
                           type="text"
                           placeholder="Enter YouTube URL"
                           class="flex-1 px-3 py-2 rounded-lg text-black focus:outline-none" />
                    <button id="loadVideoBtn"
                            class="px-4 py-2 bg-green-500 hover:bg-green-600 rounded-lg text-white font-semibold">
                        Load Video
                    </button>
                </div>
            </div>

            <!-- RIGHT: Facecam + Loudness + controls -->
            <div class="space-y-4">
                <!-- Facecam Card -->
                <div class="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-4 shadow-2xl border border-gray-700/50">
                    <h2 class="text-sm font-semibold mb-2 flex items-center gap-2">
                        <span class="w-2 h-2 bg-blue-400 rounded-full animate-pulse"></span>
                        Live Camera
                    </h2>
                    <div class="relative rounded-xl overflow-hidden bg-black">
                        <video id="facecam"
                               autoplay
                               playsinline
                               muted
                               class="w-full h-[180px] object-cover border-2 border-green-400/50">
                        </video>
                        <div class="absolute top-2 right-2 bg-red-500 rounded-full w-2 h-2 animate-pulse"></div>
                    </div>
                </div>

                <!-- Loudness / Controls Card -->
                <div class="bg-gray-800/50 backdrop-blur-sm rounded-2xl p-4 shadow-2xl border border-gray-700/50 flex flex-col" style="height: 285spx;">
                    <div>
                        <h2 class="text-sm font-semibold mb-2 flex items-center gap-2">
                            <span class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>
                            Loudness
                        </h2>
                    </div>

                    <div class="bg-black/50 rounded-xl p-3 mb-3 flex justify-center items-center" style="height: 210px;">
                        <canvas id="pitchVisualizer" width="275" height="210" class="rounded-lg"></canvas>
                    </div>

                    <!-- Sensitivity control (kept from old functionality) -->
                    <!-- <div class="bg-gray-700/30 rounded-xl p-3 mb-2">
                        <label for="sensitivitySlider" class="block text-xs font-medium text-gray-300 mb-2">Sensitivity</label>
                        <div class="flex flex-col items-center gap-2">
                            <div class="flex items-center justify-between w-full text-xs text-gray-400 mb-1">
                                <span>Low</span>
                                <span class="text-lg font-bold text-green-400" id="sensitivityValue">5.0</span>
                                <span>High</span>
                            </div>
                            <input type="range"
                                   id="sensitivitySlider"
                                   min="1"
                                   max="10"
                                   value="5"
                                   step="0.5"
                                   class="w-full">
                        </div>
                    </div> -->

                    <!-- Status -->
                    <!-- <div class="bg-gray-700/30 rounded-xl p-2 mt-auto">
                        <div id="status" class="text-center text-xs text-gray-300">
                            Requesting microphone access...
                        </div>
                        <div id="headTiltStatus" class="text-center text-xs text-gray-400 mt-1">
                            Tilt head left/right to control video
                        </div>
                    </div> -->
                </div>
            </div>
        </div>
    </div>

    <!-- SCRIPT: merged functionality (YouTube API, audio analysis, WebSocket, controls) -->
    <script>
        /*******************************
         * Shared audio / UI variables
         *******************************/
        let audioContext;
        let analyser;
        let microphone;
        let mediaStream;
        let dataArray;
        let timeDataArray;
        let bufferLength;
        let animationFrame;
        let pitchVisualizerCanvas;
        let pitchVisualizerCtx;
        let sensitivity = 5.0;
        let smoothedVolume = 0;
        const smoothingFactor = 0.9;

        // Tongue / head tilt control variables (keeps original variable names)
        let tongueWebSocket = null;
        let lastTongueAction = null;
        let tongueActionCooldown = 1000; // ms
        let lastTongueActionTime = 0;

        // YouTube player tracking variables
        let currentVideoTime = 0;
        let isPlaying = false;
        let youtubePlayerReady = false;
        let lastSeekTime = Date.now();

        /*******************************
         * YouTube iframe API helper
         * (we use postMessage commands to control the embedded iframe)
         *******************************/
        function onYouTubeIframeAPIReady() {
            // Called by the YT API; mark player ready to allow requests
            youtubePlayerReady = true;
            console.log('‚úÖ YouTube IFrame API ready');
        }

        // Update YouTube volume via postMessage
        function updateYouTubeVolume(volume) {
            const iframe = document.getElementById('youtubeFrame');
            if (iframe && iframe.contentWindow) {
                try {
                    iframe.contentWindow.postMessage(JSON.stringify({
                        event: 'command',
                        func: 'setVolume',
                        args: [volume]
                    }), '*');
                } catch (error) {
                    console.log('Could not set volume via postMessage', error);
                }
            }
        }

        // Seek helpers (use estimated time if needed)
        function getEstimatedCurrentTime() {
            if (currentVideoTime > 0) {
                return currentVideoTime;
            }
            const timeSinceSeek = (Date.now() - lastSeekTime) / 1000;
            return Math.max(0, currentVideoTime + timeSinceSeek);
        }

        function seekToSeconds(newTime) {
            const iframe = document.getElementById('youtubeFrame');
            if (!iframe || !iframe.contentWindow) return;
            iframe.contentWindow.postMessage(JSON.stringify({
                event: 'command',
                func: 'seekTo',
                args: [Math.floor(newTime), true]
            }), 'https://www.youtube.com');
            currentVideoTime = newTime;
            lastSeekTime = Date.now();
        }

        function seekForward() {
            const timeToUse = getEstimatedCurrentTime();
            const newTime = timeToUse + 10;
            seekToSeconds(newTime);
            console.log(`‚è© Forward 10s (${timeToUse.toFixed(1)}s ‚Üí ${newTime.toFixed(1)}s)`);
        }

        function seekBackward() {
            const timeToUse = getEstimatedCurrentTime();
            const newTime = Math.max(0, timeToUse - 10);
            seekToSeconds(newTime);
            console.log(`‚è™ Back 10s (${timeToUse.toFixed(1)}s ‚Üí ${newTime.toFixed(1)}s)`);
        }

        function togglePlayPause() {
            const iframe = document.getElementById('youtubeFrame');
            if (!iframe || !iframe.contentWindow) return;
            const command = JSON.stringify({
                event: 'command',
                func: isPlaying ? 'pauseVideo' : 'playVideo'
            });
            iframe.contentWindow.postMessage(command, 'https://www.youtube.com');
            isPlaying = !isPlaying;
            console.log(`‚èØÔ∏è ${isPlaying ? 'Playing' : 'Paused'}`);
        }

        /*******************************
         * Listen for messages FROM the iframe (YouTube provides info messages)
         *******************************/
        window.addEventListener('message', (event) => {
            // Only accept messages that likely originate from youtube
            // Some browsers send messages from other origins; we try-catch parsing safely
            try {
                const data = (typeof event.data === 'string') ? JSON.parse(event.data) : event.data;

                // YouTube sometimes sends { info: { currentTime: ..., playerState: ... } }
                if (data.info) {
                    if (data.info.currentTime !== undefined) {
                        currentVideoTime = data.info.currentTime;
                        lastSeekTime = Date.now();
                    }
                    if (data.info.playerState !== undefined) {
                        isPlaying = (data.info.playerState === 1);
                    }
                }

                // Also check other common properties
                if (data.currentTime !== undefined) {
                    currentVideoTime = data.currentTime;
                    lastSeekTime = Date.now();
                }
                if (data.playerState !== undefined) {
                    isPlaying = (data.playerState === 1);
                }

                if (!youtubePlayerReady) {
                    youtubePlayerReady = true;
                    console.log('‚úÖ YouTube player ready (message received)');
                }
            } catch (e) {
                // ignore non-JSON or irrelevant messages
            }
        });

        // Periodically request current time to keep tracking accurate
        setInterval(() => {
            const iframe = document.getElementById('youtubeFrame');
            if (iframe && iframe.contentWindow && youtubePlayerReady) {
                try {
                    iframe.contentWindow.postMessage(JSON.stringify({
                        event: 'command',
                        func: 'getCurrentTime'
                    }), 'https://www.youtube.com');
                } catch (e) { /* ignore */ }
            }
        }, 500);

        /*******************************
         * WebSocket for head-tilt (tongue) control
         *******************************/
        function initTongueWebSocket() {
            const wsUrl = 'ws://localhost:8765'; // same as original
            try {
                tongueWebSocket = new WebSocket(wsUrl);

                tongueWebSocket.onopen = () => {
                    console.log('‚úÖ Connected to head tilt detection server');
                    updateStatus('Head tilt control: Connected');
                    const h = document.getElementById('headTiltStatus');
                    if (h) {
                        h.textContent = '‚úÖ Connected - Tilt head to control video';
                        h.className = 'text-center text-xs text-green-400 mt-1';
                    }
                };

                tongueWebSocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        const headTilt = data.head_tilt;
                        if (!headTilt) return;

                        const now = Date.now();
                        if (headTilt !== lastTongueAction && (now - lastTongueActionTime >= tongueActionCooldown)) {
                            lastTongueAction = headTilt;
                            lastTongueActionTime = now;

                            console.log(`üë§ Head tilt: ${headTilt}`);

                            if (headTilt === 'right') {
                                seekForward();
                            } else if (headTilt === 'left') {
                                seekBackward();
                            }
                        }
                    } catch (error) {
                        console.error('Error parsing head tilt data:', error);
                    }
                };

                tongueWebSocket.onerror = (error) => {
                    console.warn('‚ö†Ô∏è Head tilt WebSocket error:', error);
                };

                tongueWebSocket.onclose = () => {
                    console.log('‚ùå Head tilt WebSocket closed. Reconnecting...');
                    updateStatus('Head tilt control: Disconnected');
                    const h = document.getElementById('headTiltStatus');
                    if (h) {
                        h.textContent = '‚ùå Disconnected - Reconnecting...';
                        h.className = 'text-center text-xs text-red-400 mt-1';
                    }
                    setTimeout(initTongueWebSocket, 3000);
                };
            } catch (error) {
                console.warn('Could not connect to head tilt detection server:', error);
            }
        }

        /*******************************
         * Status helper
         *******************************/
        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.innerHTML = `<div>${message}</div>`;
            }
        }

        /*******************************
         * Audio / volume detection
         *******************************/
        async function initAudio() {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: {
                        width: 250,
                        height: 188,
                        facingMode: 'user'
                    }
                });

                const facecam = document.getElementById('facecam');
                if (facecam && mediaStream) {
                    facecam.srcObject = mediaStream;
                    console.log('Facecam started');
                }

                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.innerHTML = '<span class="text-green-400">‚úì Microphone and camera active - Loudness controls volume</span>';
                }

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(mediaStream);

                analyser.fftSize = 4096;
                analyser.smoothingTimeConstant = 0.3;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                timeDataArray = new Float32Array(analyser.fftSize);

                microphone.connect(analyser);

                pitchVisualizerCanvas = document.getElementById('pitchVisualizer');
                pitchVisualizerCtx = pitchVisualizerCanvas.getContext('2d');

                detectVolume();
            } catch (error) {
                console.error('Error accessing microphone:', error);
                const statusEl = document.getElementById('status');
                if (statusEl) {
                    statusEl.innerHTML = `<span class="text-red-400">‚úó Error: ${error.message}</span>`;
                }
            }
        }

        function detectVolume() {
            function update() {
                if (!audioContext) return;
                animationFrame = requestAnimationFrame(update);

                analyser.getFloatTimeDomainData(timeDataArray);

                let sum = 0;
                for (let i = 0; i < timeDataArray.length; i++) {
                    const normalized = timeDataArray[i];
                    sum += normalized * normalized;
                }
                const rms = Math.sqrt(sum / timeDataArray.length);

                let volume = 0;
                if (rms > 0.001) {
                    const sensitivityMultiplier = sensitivity / 5.0;
                    const adjustedRms = Math.min(0.3, rms * sensitivityMultiplier);
                    const exponent = 0.6 - (sensitivity / 10.0 * 0.3);
                    const normalizedRms = adjustedRms / 0.3;
                    volume = Math.min(100, Math.round(Math.pow(normalizedRms, exponent) * 100));
                }

                smoothedVolume = smoothedVolume * smoothingFactor + volume * (1 - smoothingFactor);
                const finalVolume = Math.round(smoothedVolume);

                updateYouTubeVolume(finalVolume);
                drawLoudnessVisualizer(finalVolume);
            }
            update();
        }

        function drawLoudnessVisualizer(volumePercent) {
            const canvas = pitchVisualizerCanvas;
            const ctx = pitchVisualizerCtx;
            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            const position = volumePercent / 100;

            // Vertical bar - centered horizontally
            const barWidth = 60;
            const barX = (width - barWidth) / 2;
            const barMargin = 30;
            const barHeight = height - (barMargin * 2);

            // Draw background bar
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(barX, barMargin, barWidth, barHeight);

            // Calculate fill height from bottom
            const fillHeight = barHeight * position;

            // Vertical gradient (green -> yellow -> red)
            const gradient = ctx.createLinearGradient(barX, barMargin + barHeight, barX, barMargin);
            gradient.addColorStop(0, '#10b981');
            gradient.addColorStop(0.5, '#f59e0b');
            gradient.addColorStop(1, '#ef4444');

            ctx.fillStyle = gradient;
            ctx.fillRect(barX, barMargin + barHeight - fillHeight, barWidth, fillHeight);

            // Draw border
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barMargin, barWidth, barHeight);

            // Draw indicator line
            const indicatorY = barMargin + barHeight - fillHeight;
            ctx.fillStyle = volumePercent > 0 ? '#ffffff' : '#6b7280';
            ctx.fillRect(barX - 8, indicatorY - 2, barWidth + 16, 4);

            // Draw volume label
            ctx.save();
            ctx.fillStyle = volumePercent > 0 ? '#ffffff' : '#9ca3af';
            ctx.font = 'bold 14px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${volumePercent}%`, width / 2, indicatorY - 8);
            ctx.restore();

            // Top / bottom labels
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Loud (100%)', width / 2, barMargin - 10);
            ctx.fillText('Quiet (0%)', width / 2, height - barMargin + 15);
        }

        function cleanup() {
            if (animationFrame) cancelAnimationFrame(animationFrame);
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            if (tongueWebSocket) tongueWebSocket.close();
        }

        /*******************************
         * Slider initialization
         *******************************/
        function initSlider() {
            const sensitivitySlider = document.getElementById('sensitivitySlider');
            const sensitivityValue = document.getElementById('sensitivityValue');

            if (sensitivitySlider && sensitivityValue) {
                sensitivitySlider.addEventListener('input', (e) => {
                    sensitivity = parseFloat(e.target.value);
                    sensitivityValue.textContent = sensitivity.toFixed(1);
                });

                sensitivitySlider.addEventListener('change', (e) => {
                    sensitivity = parseFloat(e.target.value);
                    sensitivityValue.textContent = sensitivity.toFixed(1);
                });
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initSlider);
        } else {
            initSlider();
        }

        /*******************************
         * Load video button: convert URL to embed
         *******************************/
        document.addEventListener('click', (e) => {
            if (e.target && e.target.id === 'loadVideoBtn') {
                const input = document.getElementById('youtubeURLInput');
                let url = input.value.trim();
                if (!url) return;

                const videoIdMatch = url.match(/(?:v=|youtu\.be\/|embed\/)([a-zA-Z0-9_-]{11})/);
                if (!videoIdMatch) {
                    alert("‚ùå Invalid YouTube URL");
                    return;
                }
                const videoId = videoIdMatch[1];
                const embedUrl = `https://www.youtube.com/embed/${videoId}?enablejsapi=1&controls=1&rel=0&modestbranding=1`;
                const iframe = document.getElementById('youtubeFrame');
                iframe.src = embedUrl;
            }
        });

        /*******************************
         * Initialize everything
         *******************************/
        // Start audio/camera immediately (user must allow permissions)
        initAudio();

        // Start YouTube-related heartbeat tracking after API loads
        // onYouTubeIframeAPIReady will set youtubePlayerReady when loaded
        // Also keep polling to ask for current time from player
        setTimeout(() => {
            initTongueWebSocket();
        }, 1000);

        // Ask for current time from youtube frequently (keeps currentVideoTime fresh)
        // (Interval already set above)

        // Clean up on unload
        window.addEventListener('beforeunload', cleanup);
        window.addEventListener('unload', cleanup);
    </script>
</body>
</html>